// =======================================================
// Acknowledger
// Nathaniel Kirby
// https://github.com/nkirby/Acknowledger.git
// =======================================================

import UIKit

// =======================================================

/**
The ErrorType enum used by the Acknowledger Parser.

Acknowledger.init can throw one of three errors:

- AcknowledgerParserError.InvalidPlistFilename: no file with the filename given is found in the bundle.
- AcknowledgerParserError.InvalidPlist: the plist retrieved from the given file is malformed
- AcknowledgerParserError.MissingPreferenceSpecifiers: the plist retrieved is missing a "PreferenceSpecifiers" dictionary in the root, or the object is malformed (expecting: [String: String])

*/

public enum AcknowledgerParserError: ErrorType {
    case InvalidPlistFilename
    case InvalidPlist
    case MissingPreferenceSpecifiers
}

// =======================================================

/**
A Library is a simple struct representation of libraries passed into the Acknowledger
class
*/

public struct Library {
    
/**
The license text provided when CocoaPods generates the acknowledgements plist
*/
    
    public let license: String
    
/**
The name of the Library as generated by Cocoapods
*/
    
    public let name: String
    private var isLibrary: Bool {
        return ["Acknowledgements", ""].indexOf(self.name) == nil
    }
    
/**
Creates a Library instance. It maps:

- 'FooterText' becomes self.license
- 'Title' becomes self.name
*/
    
    public init(dict: [String: String]) {
        self.license = dict["FooterText"] ?? ""
        self.name = dict["Title"] ?? ""
    }
}

// =======================================================

/**
The Acknowledger class parses and stores the contents of your Cocoapods Acknowledgement
file into Library structs, which you can use in your own UI to display libraries used
by your app.

This class is used internally in the AcknowledgerViewController.
*/

public final class Acknowledger: NSObject {
    private var libraries = [Library]()
    
// =======================================================
// MARK: - Init, etc...
    
/**
Loads the Acknowledgement plist file included in your project.

Throws one of three errors:

- AcknowledgerParserError.InvalidPlistFilename: no file with the filename given is found in the bundle.
- AcknowledgerParserError.InvalidPlist: the plist retrieved from the given file is malformed
- AcknowledgerParserError.MissingPreferenceSpecifiers: the plist retrieved is missing a "PreferenceSpecifiers" dictionary in the root, or the object is malformed (expecting: [String: String])
*/
    
    public init(plistFilename: String) throws {
        let filename = plistFilename.stringByReplacingOccurrencesOfString(".plist", withString: "", options: NSStringCompareOptions.CaseInsensitiveSearch, range: nil)
        
        guard let path = NSBundle.mainBundle().pathForResource(filename, ofType: "plist") else {
            super.init()
            throw AcknowledgerParserError.InvalidPlistFilename
        }
        
        guard let dictionary = NSDictionary(contentsOfFile: path) as? [String: AnyObject] else {
            super.init()
            throw AcknowledgerParserError.InvalidPlist
        }
        
        super.init()

        try self.parse(plist: dictionary)
    }
   
/**
Loads the Acknowledgement dictionary passed in.

Throws the following error:

- AcknowledgerParserError.MissingPreferenceSpecifiers: the plist retrieved is missing a "PreferenceSpecifiers" dictionary in the root, or the object is malformed (expecting: [String: String])
*/

    public init(plist: [String: AnyObject]) throws {
        super.init()
        
        try self.parse(plist: plist)
    }
    
// =======================================================
// MARK: - Private Common Parser
    
    private func parse(plist plist: [String: AnyObject]) throws {
        guard let libs = plist["PreferenceSpecifiers"] as? [[String: String]] else {
            throw AcknowledgerParserError.MissingPreferenceSpecifiers
        }
        
        var libraries = [Library]()
        for lib in libs {
            let library = Library(dict: lib)
            if library.isLibrary {
                libraries.append(library)
            }
        }
        
        self.libraries = libraries
    }
    
// =======================================================
// MARK: - Retrieval
 
/**
Returns an array of all libraries loaded at init

:returns: an array of Library structs containing the parsed contents passed to init
*/
    
    public func allLibraries() -> [Library] {
        return self.libraries
    }
    
/**
Returns an array of the names of all libraries loaded at init

:returns: an array of library names
*/
    
    public func libraryNames() -> [String] {
        return self.libraries.map { $0.name }
    }
    
/**
Returns the Library struct for a Library with a given name, or nil if the library
is not found

:returns: Library?
*/
    
    public func libraryWithName(libraryName: String) -> Library? {
        return self.libraries.filter { $0.name == libraryName }.first
    }
    
/**
Returns just the license blob for a Library with a given libraryName

:returns: the string representation of the license text provided in a library
*/
    
    public func licenseForLibrary(libraryName: String) -> String? {
        return self.libraryWithName(libraryName)?.license
    }
}
